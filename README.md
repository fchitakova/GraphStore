# GraphStore

Условие



Graph Store
Вашата задача в този проект е да реализирате програма, която позволява на потребителя да дефинира различни графи и да извършва операции с тях.
Команди
Програмата трябва да има конзолен интерфейс и да може да обработва следните команди:

CREATE GRAPH <id> [directed]
Създава нов граф с идентификатор <id>. Повече информация за идентификаторите можете да намерите по-долу в документа. В системата не може да има два графа с един и същ идентификатор. Затова, ако потребителят се опита да създаде граф с идентификатор, който вече се използва от друг, трябва да се изведе подходящо съобщение и програмата не трябва да променя нищо. В противен случай трябва да се създаде нов граф и той да се направи текущ. Тази команда има втори, опционален параметър -- думата directed. Ако той бъде подаден, считаме, че графът е насочен. В противен случай, считаме, че той не е насочен.

USE GRAPH <id>
Прави графа с идентификатор <id> текущ. Ако такъв граф няма, да се изведе съобщение и да не се прави нищо.

DELETE GRAPH <id>
Изтрива графа с идентификатор <id> текущ. Ако такъв граф няма, да се изведе съобщение и да не се прави нищо. Ако този граф е бил текущ, считаме, че в системата вече няма текущ граф. Ако потребителят иска да избере нов текущ граф, той може да го направи с помощта на командата USE GRAPH.

Следващите команди служат за работа с възли и дъги. Те работят само, ако в системата има текущо избран граф. Ако такъв няма, трябва да се изведе подходящо съобщение и не трябва да се прави нищо.

CREATE NODE <id>
Създава нов връх с идентификатор <id> в текущо избрания граф. В един граф не може да има два върха с еднакви идентификатори. Ако в текущо избрания граф вече има връхс идентификатор <id>, да се изведе съобщение и да не се прави нищо.

DELETE NODE <id>
Изтрива върха с идентификатор <id> от текущо избрания граф. Ако такъв връх няма, да се изведе подходящо съобщение и да не се прави нищо.

CREATE ARC <startNodeId> <endNodeId> [<weight>]
Създава нова дъга между върховете с идентификатори <startNodeId> и <endNodeId> в текущо избрания граф. Ако графът е насочен, считаме, че дъгата започва от <startNodeId> и завършва в <endNodeId>. Ако в текущо избрания граф няма такива върхове, да се изведе съобщение за грешка и да не се прави нищо. Тази команда има трети, опционален параметър -- тегло на дъгата. Това е цяло, неотрицателно число. Ако командата се използва, без да се подаде тегло, за дъгата се задава тегло по подразбиране със стойност 1.

DELETE ARC <startNodeId> <endNodeId>
Изтрива дъгата между върховете с идентификатори <startNodeId> и <endNodeId>. Ако графът е насочен, считаме, че искаме да изтрием дъгата, започваща от <startNodeId> и завършваща в <endNodeId>. Ако графът не е насочен, потребителят може да подаде върховете в какъвто иска ред. Т.е. за ненасочен граф, следните команди биха били еквивалентни:

DELETE ARC arc1 arc2
DELETE ARC arc2 arc1

SEARCH <startNodeId> <endNodeId> <algorithm>
Проверява дали в текущо избрания граф има път започващ от върха с идентификатор <startNodeId> и стигащ до този с идентификатор <endNodeId>. Търсенето трябва да стане с помощта на алгоритъма указан в параметъра <algorithm>. Възможните стойности на <algorithm> са описани по-долу:
bfs -- търси път с помощта на алгоритъма за обхождане в широчина;
dfs-shortest -- търси най-кратък път между двата върха, с помощта на алгоритъма за обхождане в дълбочина;
dfs-longest -- търси най-дълъг път между двата върха, с помощта на алгоритъма за обхождане в дълбочина;
dijkstra -- намира най-евтин (като сума от ребра) път между два върха, като за целта използва алгоритъма на Дейкстра

Ако някой от двата върха не се съдържа в графа или между тях няма път, да се изведе подходящо съобщение. В противен случай, ако програмата успее да намери път, тя трябва да изведе съобщение за това, че е намерен път, следвано от
поредицата от възли, които пътят съдържа. Ако пътят се търси с помощта на алгоритъма на Дейкстра, да се изведе и неговата цена.

За допълнителни точки, реализирайте допълнителни алгоритми и/или функционалности, като например:

Откриване на свързани компоненти;
Решаване на задачата за търговския пътник;
Построяване на минимално покриващо дърво за даден граф и съхраняването му, така че то да може да се използва по-късно за различни цели (в този случай помислете за подходящи команди за работа с дървото и за това как да го обновите или направите невалидно, ако се направи промяна в графа);
и др.

За тях добавете към програмата подходящи команди и изберете какво да извеждат те на екрана и както да бъде тяхното поведение при грешка.
